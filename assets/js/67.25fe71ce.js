(window.webpackJsonp=window.webpackJsonp||[]).push([[67],{371:function(v,_,e){"use strict";e.r(_);var t=e(6),a=Object(t.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"数据库日期类型字段设计-应该如何选择"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#数据库日期类型字段设计-应该如何选择"}},[v._v("#")]),v._v(" 数据库日期类型字段设计，应该如何选择?")]),v._v(" "),_("p",[v._v("      当设计一个产品，其中很多地方要把日期类型保存到数据库中，如果产品有兼容不同数据库产品的需求，那么，应当怎样设计呢？")]),v._v(" "),_("h2",{attrs:{id:"mysql"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#mysql"}},[v._v("#")]),v._v(" MySQL：")]),v._v(" "),_("p",[v._v("      当然，首先想到的是，使用数据库的Date或DateTime类型，可是看看不同数据库这些类型间的区别吧，真让人望而止步。MySQL数据库：它们分别是date、datetime、time、timestamp和year。")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("date")]),v._v('："yyyy-mm-dd"格式表示的日期值')]),v._v(" "),_("li",[_("strong",[v._v("datetime")]),v._v('："yyyy-mm-dd hh:mm:ss"格式')]),v._v(" "),_("li",[_("strong",[v._v("time")]),v._v('："hh:mm:ss"格式表示的时间值')]),v._v(" "),_("li",[_("strong",[v._v("timestamp")]),v._v('："yyyymmddhhmmss"格式表示的时间戳值')]),v._v(" "),_("li",[_("strong",[v._v("year")]),v._v('："yyyy"格式的年份值')])]),v._v(" "),_("p",[v._v("范围：")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("date")]),v._v('："1000-01-01"到""3字节')]),v._v(" "),_("li",[_("strong",[v._v("datetime")]),v._v('："1000-01-01 00:00:00"到"9999-12-31 23:59:59"8字节')]),v._v(" "),_("li",[_("strong",[v._v("time")]),v._v('："-838:59:59"到"838:59:59"3字节')]),v._v(" "),_("li",[_("strong",[v._v("timestamp")]),v._v('："19700101000000"到"2037"年的某个时刻4字节')]),v._v(" "),_("li",[_("strong",[v._v("year")]),v._v('："1901"到"2155"1字节')])]),v._v(" "),_("h2",{attrs:{id:"oracle-数据库"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#oracle-数据库"}},[v._v("#")]),v._v(" Oracle 数据库：")]),v._v(" "),_("p",[v._v("Date 类型的内部编码为12")]),v._v(" "),_("p",[v._v("长度:占用7个字节")]),v._v(" "),_("p",[v._v("数据存储的每一位到第七位分别为：世纪，年，月，日，时，分，秒")]),v._v(" "),_("p",[_("code",[v._v("TIMESTAMP")]),v._v("是支持小数秒和时区的日期/时间类型。对秒的精确度更高")]),v._v(" "),_("p",[_("code",[v._v("TIMESTAMP WITH TIME ZONE")]),v._v(" 类型是 TIMESTAMP 的子类型，增加了时区支持，占用13字节的存储空间，最后两位用于保存时区信息")]),v._v(" "),_("p",[_("code",[v._v("INTERVAL")]),v._v(" 用于表示一段时间或一个时间间隔的方法。在前面有多次提过。INTERVAL有两种类型.")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("YEAR TO MONTH")]),v._v(" 能存储年或月指定的一个时间段.")]),v._v(" "),_("li",[_("code",[v._v("DATE TO SECOND")]),v._v(" 存储天,小时,分钟,秒指定的时间段.")])]),v._v(" "),_("h2",{attrs:{id:"sql-server"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#sql-server"}},[v._v("#")]),v._v(" sql server：")]),v._v(" "),_("blockquote",[_("p",[v._v("datetime 和 smalldatetime")])]),v._v(" "),_("ul",[_("li",[_("code",[v._v("datetime")]),v._v("数据类型所占用的存储空间为8个字节，其中前4个字节用于存储1900年1月1日以前或以后的天数，数值分正负，正数表示在此日期之后的日期，负数表示在此日期之前的日期；后4个字节用于存储从此日零时起所指定的时间经过的毫秒数。")]),v._v(" "),_("li",[_("code",[v._v("smalldatetime")]),v._v("数据类型使用4个字节存储数据。其中前2个字节存储从基础日期1900年1月1日以来的天数，后两个字节存储此日零时起所指定的时间经过的分钟数。")]),v._v(" "),_("li",[_("code",[v._v("smalldatetime")]),v._v("数据类型与"),_("code",[v._v("datetime")]),v._v("数据类型相似，但其日期时间范围较小，从1900年1月1日到2079年6月6日。此数据类型精度较低，只能精确到分钟，其分钟个位为根据秒数四舍五入的值，即以30秒为界四舍五入。")])]),v._v(" "),_("p",[v._v("如果没有兼容多种数据库这个要求，我会毫不犹豫的使用数据库的 Date 类型。因为如果使用 Java 框架产生代码，对数据库中定义为 Date 类型的字段，甚至能在页面上产生出JS的时间选择框，的确能节省很多开发时间。而兼容不同数据库，就希望产品在由一种数据库，迁移到另外一种数据库时，尽可能小的代价，使用了 Date，看来就很困难了。")]),v._v(" "),_("p",[_("span",{staticStyle:{color:"red"}},[_("strong",[v._v("有一个疑问，不知道目前流行的ORM对这个处理得是不是好？因为工作不怎么涉及这方面，所以不大了解。")])])]),v._v(" "),_("p",[v._v("在之前的设计开发中，因为有支持多种数据库这种需求，所以首先否定了日期时间这样的类型。")]),v._v(" "),_("p",[v._v("曾经使用过毫秒数（Java 的 "),_("code",[v._v("System.currentTimeMillis()")]),v._v("）这种方式，但是选用这个方式，考虑的不是使用起来是否方便或者数据迁移，而是考虑到下面的原因：")]),v._v(" "),_("blockquote",[_("p",[v._v("Java 取到的毫秒数是对时间点的一种准确描述。定义如下："),_("code",[v._v("java.lang.System.currentTimeMillis()")]),v._v("，它返回从 UTC 1970 年 1 月 1 日午夜开始经过的毫秒数。")])]),v._v(" "),_("p",[v._v("我们可以看到，这个定义，保证了这个时间值能够被后续设计开发的人员正确和准确的理解，能够为所有的应用正确理解，能够在所有时区上正确反映为正常的时间形式。")]),v._v(" "),_("p",[v._v("当时的产品设计是有海外客户的，所以当时的设计，在数据库里保存的，应该是一个“准确的时间”。例如“"),_("code",[v._v("20120926080000")]),v._v("”实际上并没有严格的表示出时间，因为北京时间2012年9月26日8点和格林威治时间2012年9月26日8点显然是不一样的。")]),v._v(" "),_("p",[v._v("虽然我们都是在一个确切的时区里，例如中国都是使用东八区时间，但是需要考虑的是：")]),v._v(" "),_("ul",[_("li",[v._v("有些产品是可能有海外客户的")]),v._v(" "),_("li",[v._v("产品所运行的机器，时区的设置未必都是东八区。")])]),v._v(" "),_("p",[v._v("在这种情况下，如果数据库里的时间不准确，会给程序运行带来问题。这种方式最大的缺点在于：")]),v._v(" "),_("ul",[_("li",[v._v("不方便对时间进行分组查询，比如按月统计、按季统计")]),v._v(" "),_("li",[v._v("DBA在维护时，不能直观的根据返回的行结果，看到简单明了的结果（看到的是毫秒数）")]),v._v(" "),_("li",[v._v("另外，公众号Java精选，回复java面试，获取面试资料。")])]),v._v(" "),_("p",[v._v("使用这种方式的特点是牺牲一点易用性和可理解性（不易于维护和理解），满足了查询结果的直观性和准确性要求，同时最大限度考虑运行效率。")]),v._v(" "),_("p",[v._v("为了解决这个问题，我设计了一个辅助的措施，就是建立一个数据库函数来进行时间转换，把毫秒数的时间转为制定时区和格式的时间串，DBA 在维护时可以使用。测试了 "),_("a",{attrs:{href:"http://mp.weixin.qq.com/s?__biz=MzAwMTE3MDY4MQ==&mid=2652453867&idx=1&sn=9513864f88fb6b322165094701a97f05&chksm=8130567db647df6bd08c700fe999e8ffffbad3d3cc6fbdded14f908af24416b11f1a9e387d51&scene=21#wechat_redirect",target:"_blank",rel:"noopener noreferrer"}},[v._v("Oracle"),_("OutboundLink")],1),v._v(" 和 DB2 上，都可以这样。")]),v._v(" "),_("p",[v._v("例如之前的查询的时候为：")]),v._v(" "),_("div",{staticClass:"language- line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("SELECT username,user_addtime from userinfo\n")])]),v._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[v._v("1")]),_("br")])]),_("p",[v._v("这个查询显示的是毫秒数，使用内置函数后写成：")]),v._v(" "),_("div",{staticClass:"language- line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("SELECT username,date2str(user_addtime) from userinfo\n")])]),v._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[v._v("1")]),_("br")])]),_("p",[v._v("这样返回的就是东八区、预先定义好格式的字符串了。")]),v._v(" "),_("p",[v._v("在之后的设计里，还使用过 "),_("code",[v._v("YYYYMMDDHHmmSST")]),v._v(" 格式，其中的“T”指时区，加入时区，带来的影响有：")]),v._v(" "),_("ul",[_("li",[v._v("日期时间字段就不能在使用数值来存储了，字符串比数字存储和检索的效率都要低。")]),v._v(" "),_("li",[v._v("应用程序需要加上额外的处理")])]),v._v(" "),_("p",[v._v("带来的好处是：")]),v._v(" "),_("ul",[_("li",[v._v("便于 DBA 维护")]),v._v(" "),_("li",[v._v("到什么时候，即便没有看到数据库设计文档，都能看明白并准确理解数据库中一条信息中，这个字段保存到确切信息")])]),v._v(" "),_("p",[v._v("使用这种方式的特点是牺牲一点效率，满足了查询结果的直观性和准确性要求。")]),v._v(" "),_("p",[_("strong",[v._v("总结一下，字段类型的选择，还是根据场景的需要来选择，从功能、效率要求、持续开发的要求、维护的要求几个方面综合考虑。")])])])}),[],!1,null,null,null);_.default=a.exports}}]);