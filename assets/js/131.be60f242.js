(window.webpackJsonp=window.webpackJsonp||[]).push([[131],{435:function(a,s,t){"use strict";t.r(s);var v=t(6),_=Object(v.a)({},(function(){var a=this,s=a._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h2",{attrs:{id:"序列化和反序列化相关概念"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#序列化和反序列化相关概念"}},[a._v("#")]),a._v(" 序列化和反序列化相关概念")]),a._v(" "),s("h3",{attrs:{id:"什么是序列化-什么是反序列化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#什么是序列化-什么是反序列化"}},[a._v("#")]),a._v(" 什么是序列化?什么是反序列化?")]),a._v(" "),s("p",[a._v("如果我们需要持久化 Java 对象比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，这些场景都需要用到序列化。")]),a._v(" "),s("p",[a._v("简单来说：")]),a._v(" "),s("ul",[s("li",[s("strong",[a._v("序列化")]),a._v("： 将数据结构或对象转换成二进制字节流的过程")]),a._v(" "),s("li",[s("strong",[a._v("反序列化")]),a._v("：将在序列化过程中所生成的二进制字节流的过程转换成数据结构或者对象的过程")])]),a._v(" "),s("p",[a._v("对于Java这种面向对象编程语言来说，我们序列化的都是对象（Object）也就是实例化后的类（Class），但是在C++这种半面向对象的语言中，struct（结构体）定义的就是数据结构类型，而class对应的是对象类型。")]),a._v(" "),s("p",[a._v("维基百科是这样介绍序列化的：")]),a._v(" "),s("blockquote",[s("p",[s("strong",[a._v("序列化（serialization）")]),a._v(" 在计算机科学的数据处理中，是指将数据结构或对象状态转换成可取用格式（例如存成文件，存于缓冲，或经由网络中发送），以留待后续在相同或另一台计算机环境中，能够恢复原先状态的过程。依照序列化格式重新获取字节的结果时，可以利用他来产生与原始对象相同语义的副本。对于许多对象，像是使用大量引用的复杂对象，这种序列化重建的过程并不容易。面向对象中的对象序列化，并不是概括之前对象所关系的函数。这种过程也称为对象编组（marshalling）、从一系列字节提取数据结构的反向操作，是反序列化（也称解编程组、deserialization、unmarshalling）。")])]),a._v(" "),s("p",[a._v("综上："),s("strong",[a._v("序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。")])]),a._v(" "),s("p",[s("img",{attrs:{src:"http://yz-typora-img.oss-cn-shanghai.aliyuncs.com/img/image-20220803113802863.png",alt:"image-20220803113802863"}})]),a._v(" "),s("h3",{attrs:{id:"实际开发中有哪些用到序列化和反序列化的场景"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#实际开发中有哪些用到序列化和反序列化的场景"}},[a._v("#")]),a._v(" 实际开发中有哪些用到序列化和反序列化的场景？")]),a._v(" "),s("ol",[s("li",[a._v("对象在进行网络传输（比如远程方法调用RPC的时候）之前需要先被序列化，接收到序列化对象之后需要在进行反序列化；")]),a._v(" "),s("li",[a._v("将对象存储到文件中的时候需要进行序列化，将对象从文件读取出来需要进行反序列化。")]),a._v(" "),s("li",[a._v("将对象存储到缓存数据库（如Redis）时需要用到序列化，将对象从缓存数据库中读取出来的时候需要反序列化。")])]),a._v(" "),s("h3",{attrs:{id:"序列化协议对应tcp-ip4层模型的哪一层"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#序列化协议对应tcp-ip4层模型的哪一层"}},[a._v("#")]),a._v(" 序列化协议对应TCP/IP4层模型的哪一层？")]),a._v(" "),s("p",[a._v("我们知道网络通信的双方必须要采用和遵守相同的协议。TCP/IP四层模型是下面这样的，序列化协议属于哪一层呢?")]),a._v(" "),s("ol",[s("li",[a._v("应用层")]),a._v(" "),s("li",[a._v("传输层")]),a._v(" "),s("li",[a._v("网络层")]),a._v(" "),s("li",[a._v("网络接口层")])]),a._v(" "),s("p",[s("img",{attrs:{src:"http://yz-typora-img.oss-cn-shanghai.aliyuncs.com/img/image-20220803114955025.png",alt:"image-20220803114955025"}})]),a._v(" "),s("p",[a._v("如上图所示，OSI 七层协议模型中，表示层做的事情主要就是对应用层的用户数据进行处理转换为二进制流。反过来的话，就是将二进制流转换成应用层的用户数据。这不就对应的是序列化和反序列化么？")]),a._v(" "),s("p",[a._v("因为，OSI 七层协议模型中的应用层、表示层和会话层对应的都是 TCP/IP 四层模型中的应用层，所以序列化协议属于 TCP/IP 协议应用层的一部分。")]),a._v(" "),s("h2",{attrs:{id:"常见序列化协议对比"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#常见序列化协议对比"}},[a._v("#")]),a._v(" 常见序列化协议对比")]),a._v(" "),s("p",[a._v("JDK 自带的序列化方式一般不会用 ，因为序列化效率低并且部分版本有安全漏洞。比较常用的序列化协议有 hessian、kyro、protostuff。")]),a._v(" "),s("p",[a._v("下面提到的都是基于二进制的序列化协议，像 JSON 和 XML 这种属于文本类序列化方式。虽然 JSON 和 XML 可读性比较好，但是性能较差，一般不会选择。")]),a._v(" "),s("h3",{attrs:{id:"jdk-自带的序列化方式"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#jdk-自带的序列化方式"}},[a._v("#")]),a._v(" JDK 自带的序列化方式")]),a._v(" "),s("p",[a._v("JDK 自带的序列化，只需实现 "),s("code",[a._v("java.io.Serializable")]),a._v("接口即可。")]),a._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[a._v("@AllArgsConstructor")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[a._v("@NoArgsConstructor")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[a._v("@Getter")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[a._v("@Builder")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token annotation punctuation"}},[a._v("@ToString")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("RpcRequest")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("implements")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Serializable")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("private")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("final")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("long")]),a._v(" serialVersionUID "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1905122041950251207L")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("private")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),a._v(" requestId"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("private")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),a._v(" interfaceName"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("private")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),a._v(" methodName"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("private")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Object")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" parameters"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("private")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Class")]),s("span",{pre:!0,attrs:{class:"token generics"}},[s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("<")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("?")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(">")])]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" paramTypes"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("private")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("RpcMessageTypeEnum")]),a._v(" rpcMessageTypeEnum"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br"),s("span",{staticClass:"line-number"},[a._v("10")]),s("br"),s("span",{staticClass:"line-number"},[a._v("11")]),s("br"),s("span",{staticClass:"line-number"},[a._v("12")]),s("br"),s("span",{staticClass:"line-number"},[a._v("13")]),s("br"),s("span",{staticClass:"line-number"},[a._v("14")]),s("br")])]),s("blockquote",[s("p",[a._v("      序列化号 serialVersionUID 属于版本控制的作用。序列化的时候 serialVersionUID 也会被写入二级制序列，当反序列化时会检查 serialVersionUID 是否和当前类的 serialVersionUID 一致。如果 serialVersionUID 不一致则会抛出 "),s("code",[a._v("InvalidClassException")]),a._v(" 异常。强烈推荐每个序列化类都手动指定其 "),s("code",[a._v("serialVersionUID")]),a._v("，如果不手动指定，那么编译器会动态生成默认的序列化号")])]),a._v(" "),s("p",[a._v("我们很少或者说几乎不会直接使用这个序列化方式，主要原因有两个：")]),a._v(" "),s("ol",[s("li",[s("strong",[a._v("不支持跨语言调用")]),a._v(" : 如果调用的是其他语言开发的服务的时候就不支持了。")]),a._v(" "),s("li",[s("strong",[a._v("性能差")]),a._v(" ：相比于其他序列化框架性能更低，主要原因是序列化之后的字节数组体积较大，导致传输成本加大。")])]),a._v(" "),s("h3",{attrs:{id:"xml"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#xml"}},[a._v("#")]),a._v(" XML")]),a._v(" "),s("p",[a._v("（1）定义：")]),a._v(" "),s("p",[a._v("XML（Extensible Markup Language）是一种常用的序列化和反序列化协议， 它历史悠久，从1998年的1.0版本被广泛使用至今。")]),a._v(" "),s("p",[a._v("（2）优点")]),a._v(" "),s("ul",[s("li",[a._v("人机可读性好")]),a._v(" "),s("li",[a._v("可指定元素或特性的名称")])]),a._v(" "),s("p",[a._v("（3）缺点")]),a._v(" "),s("ul",[s("li",[a._v("序列化数据只包含数据本身以及类的结构，不包括类型标识和程序集信息。")]),a._v(" "),s("li",[a._v("类必须有一个将由 XmlSerializer 序列化的默认构造函数。")]),a._v(" "),s("li",[a._v("只能序列化公共属性和字段")]),a._v(" "),s("li",[a._v("不能序列化方法")]),a._v(" "),s("li",[a._v("文件庞大，文件格式复杂，传输占带宽")])]),a._v(" "),s("p",[a._v("（4）使用场景")]),a._v(" "),s("ul",[s("li",[a._v("当做配置文件存储数据")]),a._v(" "),s("li",[a._v("实时数据转换")])]),a._v(" "),s("h3",{attrs:{id:"json"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#json"}},[a._v("#")]),a._v(" JSON")]),a._v(" "),s("p",[a._v("（1）定义：")]),a._v(" "),s("p",[a._v("JSON(JavaScript Object Notation, JS 对象标记) 是一种轻量级的数据交换格式。它基于 ECMAScript (w3c制定的js规范)的一个子集， JSON采用与编程语言无关的文本格式，但是也使用了类C语言（包括C， C++， C#， Java， JavaScript， Perl， Python等）的习惯，简洁和清晰的层次结构使得 JSON 成为理想的数据交换语言。")]),a._v(" "),s("p",[a._v("（2）优点")]),a._v(" "),s("ul",[s("li",[a._v("前后兼容性高")]),a._v(" "),s("li",[a._v("数据格式比较简单，易于读写")]),a._v(" "),s("li",[a._v("序列化后数据较小，可扩展性好，兼容性好")]),a._v(" "),s("li",[a._v("与XML相比，其协议比较简单，解析速度比较快")])]),a._v(" "),s("p",[a._v("（3）缺点")]),a._v(" "),s("ul",[s("li",[a._v("数据的描述性比XML差")]),a._v(" "),s("li",[a._v("不适合性能要求为ms级别的情况")]),a._v(" "),s("li",[a._v("额外空间开销比较大")])]),a._v(" "),s("p",[a._v("（4）适用场景（可替代ＸＭＬ）")]),a._v(" "),s("ul",[s("li",[a._v("跨防火墙访问")]),a._v(" "),s("li",[a._v("可调式性要求高的情况")]),a._v(" "),s("li",[a._v("基于Web browser的Ajax请求")]),a._v(" "),s("li",[a._v("传输数据量相对小，实时性要求相对低（例如秒级别）的服务")])]),a._v(" "),s("h3",{attrs:{id:"fastjson"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#fastjson"}},[a._v("#")]),a._v(" Fastjson")]),a._v(" "),s("p",[a._v("（1）定义")]),a._v(" "),s("p",[a._v("Fastjson是一个Java语言编写的高性能功能完善的JSON库。它采用一种“假定有序快速匹配”的算法，把JSON Parse的性能提升到极致。")]),a._v(" "),s("p",[a._v("（2）优点")]),a._v(" "),s("ul",[s("li",[a._v("接口简单易用")]),a._v(" "),s("li",[a._v("目前java语言中最快的json库")])]),a._v(" "),s("p",[a._v("（3）缺点")]),a._v(" "),s("ul",[s("li",[a._v("过于注重快，而偏离了“标准”及功能性")]),a._v(" "),s("li",[a._v("代码质量不高，文档不全")])]),a._v(" "),s("p",[a._v("（4）适用场景")]),a._v(" "),s("ul",[s("li",[a._v("协议交互")]),a._v(" "),s("li",[a._v("Web输出")]),a._v(" "),s("li",[a._v("Android客户端")])]),a._v(" "),s("h3",{attrs:{id:"avro"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#avro"}},[a._v("#")]),a._v(" Avro")]),a._v(" "),s("p",[a._v("（1）定义：")]),a._v(" "),s("p",[a._v("Avro属于Apache Hadoop的一个子项目。 Avro提供两种序列化格式：JSON格式或者Binary格式。Binary格式在空间开销和解析性能方面可以和Protobuf媲美，Avro的产生解决了JSON的冗长和没有IDL的问题")]),a._v(" "),s("p",[a._v("（2）优点")]),a._v(" "),s("ul",[s("li",[a._v("支持丰富的数据类型")]),a._v(" "),s("li",[a._v("简单的动态语言结合功能")]),a._v(" "),s("li",[a._v("具有自我描述属性")]),a._v(" "),s("li",[a._v("提高了数据解析速度")]),a._v(" "),s("li",[a._v("快速可压缩的二进制数据形式")]),a._v(" "),s("li",[a._v("可以实现远程过程调用RPC")]),a._v(" "),s("li",[a._v("支持跨编程语言实现")])]),a._v(" "),s("p",[a._v("（3）缺点")]),a._v(" "),s("ul",[s("li",[a._v("对于习惯于静态类型语言的用户不直观")])]),a._v(" "),s("p",[a._v("（4）适用场景")]),a._v(" "),s("ul",[s("li",[a._v("在Hadoop中做Hive、Pig和MapReduce的持久化数据格式")])]),a._v(" "),s("h3",{attrs:{id:"protobuf"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#protobuf"}},[a._v("#")]),a._v(" Protobuf")]),a._v(" "),s("p",[a._v("（1）定义")]),a._v(" "),s("p",[a._v("protocol buffers 由谷歌开源而来，在谷歌内部久经考验。它将数据结构以.proto文件进行描述，通过代码生成工具可以生成对应数据结构的POJO对象和Protobuf相关的方法和属性。")]),a._v(" "),s("p",[a._v("（2）优点")]),a._v(" "),s("ul",[s("li",[a._v("序列化后码流小，性能高")]),a._v(" "),s("li",[a._v("结构化数据存储格式（XML JSON等）")]),a._v(" "),s("li",[a._v("通过标识字段的顺序，可以实现协议的前向兼容")]),a._v(" "),s("li",[a._v("结构化的文档更容易管理和维护")])]),a._v(" "),s("p",[a._v("（3）缺点")]),a._v(" "),s("ul",[s("li",[a._v("需要依赖于工具生成代码")]),a._v(" "),s("li",[a._v("支持的语言相对较少，官方只支持Java 、C++ 、Python")])]),a._v(" "),s("p",[a._v("（4）适用场景")]),a._v(" "),s("ul",[s("li",[a._v("对性能要求高的RPC调用")]),a._v(" "),s("li",[a._v("具有良好的跨防火墙的访问属性")]),a._v(" "),s("li",[a._v("适合应用层对象的持久化")])]),a._v(" "),s("h3",{attrs:{id:"其它"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#其它"}},[a._v("#")]),a._v(" 其它")]),a._v(" "),s("ul",[s("li",[a._v("protostuff 基于protobuf协议，但不需要配置proto文件，直接导包即")]),a._v(" "),s("li",[a._v("Jboss marshaling 可以直接序列化java类， 无须实java.io.Serializable接口")]),a._v(" "),s("li",[a._v("Message pack 一个高效的二进制序列化格式")]),a._v(" "),s("li",[a._v("Hessian 采用二进制协议的轻量级remoting onhttp工具")]),a._v(" "),s("li",[a._v("kryo 基于protobuf协议，只支持java语言,需要注册（Registration），然后序列化（Output），反序列化（Input）")])]),a._v(" "),s("h3",{attrs:{id:"性能对比图解"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#性能对比图解"}},[a._v("#")]),a._v(" 性能对比图解")]),a._v(" "),s("p",[s("strong",[a._v("时间")])]),a._v(" "),s("p",[s("img",{attrs:{src:"http://yz-typora-img.oss-cn-shanghai.aliyuncs.com/img/image-20220803120028497.png",alt:"image-20220803120028497"}})]),a._v(" "),s("p",[s("strong",[a._v("空间")])]),a._v(" "),s("p",[s("img",{attrs:{src:"http://yz-typora-img.oss-cn-shanghai.aliyuncs.com/img/image-20220803120041072.png",alt:"image-20220803120041072"}})]),a._v(" "),s("p",[s("strong",[a._v("分析上图知：")])]),a._v(" "),s("ul",[s("li",[a._v("XML序列化（Xstream）无论在性能和简洁性上比较差。")]),a._v(" "),s("li",[a._v("Thrift与Protobuf相比在时空开销方面都有一定的劣势。")]),a._v(" "),s("li",[a._v("Protobuf和Avro在两方面表现都非常优越。")])]),a._v(" "),s("h3",{attrs:{id:"选型建议"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#选型建议"}},[a._v("#")]),a._v(" 选型建议")]),a._v(" "),s("p",[s("strong",[a._v("不同的场景适用的序列化协议：")])]),a._v(" "),s("ul",[s("li",[a._v("对于公司间的系统调用，如果性能要求在100ms以上的服务，基于XML的SOAP协议是一个值得考虑的方案。")]),a._v(" "),s("li",[a._v("基于Web browser的Ajax，以及Mobile app与服务端之间的通讯，JSON协议是首选。对于性能要求不太高，或者以动态类型语言为主，或者传输数据载荷很小的的运用场景，JSON也是非常不错的选择。")]),a._v(" "),s("li",[a._v("对于调试环境比较恶劣的场景，采用JSON或XML能够极大的提高调试效率，降低系统开发成本。")]),a._v(" "),s("li",[a._v("当对性能和简洁性有极高要求的场景，Protobuf，Thrift，Avro之间具有一定的竞争关系。")]),a._v(" "),s("li",[a._v("对于T级别的数据的持久化应用场景，Protobuf和Avro是首要选择。如果持久化后的数据存储在Hadoop子项目里，Avro会是更好的选择。")]),a._v(" "),s("li",[a._v("由于Avro的设计理念偏向于动态类型语言，对于动态语言为主的应用场景，Avro是更好的选择。")]),a._v(" "),s("li",[a._v("对于持久层非Hadoop项目，以静态类型语言为主的应用场景，Protobuf会更符合静态类型语言工程师的开发习惯。")]),a._v(" "),s("li",[a._v("如果需要提供一个完整的RPC解决方案，Thrift是一个好的选择。")]),a._v(" "),s("li",[a._v("如果序列化之后需要支持不同的传输层协议，或者需要跨防火墙访问的高性能场景，Protobuf可以优先考虑。")])])])}),[],!1,null,null,null);s.default=_.exports}}]);