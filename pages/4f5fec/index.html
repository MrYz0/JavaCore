<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Java并发简介 | Yangzhou&#39;s blog</title>
    <meta name="generator" content="VuePress 1.9.5">
    <link rel="icon" href="/JavaCore/img/favicon.ico">
    <meta name="description" content="web前端技术博客,专注web前端学习与总结。JavaScript,js,ES6,TypeScript,vue,React,python,css3,html5,Node,git,github等技术文章。">
    <meta name="keywords" content="前端博客,个人技术博客,前端,前端开发,前端框架,web前端,前端面试题,技术文档,学习,面试,JavaScript,js,ES6,TypeScript,vue,python,css3,html5,Node,git,github,markdown">
    <meta name="baidu-site-verification" content="7F55weZDDc">
    <meta name="theme-color" content="#11a8cd">
    
    <link rel="preload" href="/JavaCore/assets/css/0.styles.cc85f9e9.css" as="style"><link rel="preload" href="/JavaCore/assets/js/app.dbe5bb79.js" as="script"><link rel="preload" href="/JavaCore/assets/js/2.cf8b9bc2.js" as="script"><link rel="preload" href="/JavaCore/assets/js/108.8037c42e.js" as="script"><link rel="prefetch" href="/JavaCore/assets/js/10.9f090219.js"><link rel="prefetch" href="/JavaCore/assets/js/100.29326bf6.js"><link rel="prefetch" href="/JavaCore/assets/js/101.ed219511.js"><link rel="prefetch" href="/JavaCore/assets/js/102.1849f36a.js"><link rel="prefetch" href="/JavaCore/assets/js/103.26048576.js"><link rel="prefetch" href="/JavaCore/assets/js/104.eecd0015.js"><link rel="prefetch" href="/JavaCore/assets/js/105.61fc1cbf.js"><link rel="prefetch" href="/JavaCore/assets/js/106.ac630438.js"><link rel="prefetch" href="/JavaCore/assets/js/107.b54a458a.js"><link rel="prefetch" href="/JavaCore/assets/js/109.9212d109.js"><link rel="prefetch" href="/JavaCore/assets/js/11.9a7f2cc5.js"><link rel="prefetch" href="/JavaCore/assets/js/110.1f43ffb0.js"><link rel="prefetch" href="/JavaCore/assets/js/111.bdc6762f.js"><link rel="prefetch" href="/JavaCore/assets/js/112.8db475ef.js"><link rel="prefetch" href="/JavaCore/assets/js/113.1b707a82.js"><link rel="prefetch" href="/JavaCore/assets/js/114.487bbb17.js"><link rel="prefetch" href="/JavaCore/assets/js/115.cf5da376.js"><link rel="prefetch" href="/JavaCore/assets/js/116.b1a94ddc.js"><link rel="prefetch" href="/JavaCore/assets/js/117.9b286be7.js"><link rel="prefetch" href="/JavaCore/assets/js/118.92c02ebd.js"><link rel="prefetch" href="/JavaCore/assets/js/119.d10444ee.js"><link rel="prefetch" href="/JavaCore/assets/js/12.4e4bc020.js"><link rel="prefetch" href="/JavaCore/assets/js/120.e8b94366.js"><link rel="prefetch" href="/JavaCore/assets/js/121.a4b4532c.js"><link rel="prefetch" href="/JavaCore/assets/js/122.a5a58616.js"><link rel="prefetch" href="/JavaCore/assets/js/123.ac19b759.js"><link rel="prefetch" href="/JavaCore/assets/js/124.c59d8ea6.js"><link rel="prefetch" href="/JavaCore/assets/js/125.7fa7248f.js"><link rel="prefetch" href="/JavaCore/assets/js/126.58693f82.js"><link rel="prefetch" href="/JavaCore/assets/js/127.2b7164af.js"><link rel="prefetch" href="/JavaCore/assets/js/128.b0263be1.js"><link rel="prefetch" href="/JavaCore/assets/js/129.f84d6fd7.js"><link rel="prefetch" href="/JavaCore/assets/js/13.8a0efd09.js"><link rel="prefetch" href="/JavaCore/assets/js/130.01ea4ae5.js"><link rel="prefetch" href="/JavaCore/assets/js/131.be60f242.js"><link rel="prefetch" href="/JavaCore/assets/js/132.c2c51989.js"><link rel="prefetch" href="/JavaCore/assets/js/133.8f9dafb8.js"><link rel="prefetch" href="/JavaCore/assets/js/134.01e63d8c.js"><link rel="prefetch" href="/JavaCore/assets/js/135.525c2b82.js"><link rel="prefetch" href="/JavaCore/assets/js/136.63f1b874.js"><link rel="prefetch" href="/JavaCore/assets/js/137.d21c2148.js"><link rel="prefetch" href="/JavaCore/assets/js/138.624e083e.js"><link rel="prefetch" href="/JavaCore/assets/js/139.f7e8952b.js"><link rel="prefetch" href="/JavaCore/assets/js/14.498f0f13.js"><link rel="prefetch" href="/JavaCore/assets/js/140.dab308bd.js"><link rel="prefetch" href="/JavaCore/assets/js/141.1ac256fd.js"><link rel="prefetch" href="/JavaCore/assets/js/142.7a9fa726.js"><link rel="prefetch" href="/JavaCore/assets/js/143.b68131a3.js"><link rel="prefetch" href="/JavaCore/assets/js/144.82e8baaa.js"><link rel="prefetch" href="/JavaCore/assets/js/145.99979fc8.js"><link rel="prefetch" href="/JavaCore/assets/js/15.39f67d96.js"><link rel="prefetch" href="/JavaCore/assets/js/16.48d66c2b.js"><link rel="prefetch" href="/JavaCore/assets/js/17.1e056961.js"><link rel="prefetch" href="/JavaCore/assets/js/18.3f37c5b4.js"><link rel="prefetch" href="/JavaCore/assets/js/19.a00e4ca5.js"><link rel="prefetch" href="/JavaCore/assets/js/20.91ede9d4.js"><link rel="prefetch" href="/JavaCore/assets/js/21.97d95015.js"><link rel="prefetch" href="/JavaCore/assets/js/22.782f1f6b.js"><link rel="prefetch" href="/JavaCore/assets/js/23.f564b434.js"><link rel="prefetch" href="/JavaCore/assets/js/24.26e1a731.js"><link rel="prefetch" href="/JavaCore/assets/js/25.ccb93a96.js"><link rel="prefetch" href="/JavaCore/assets/js/26.c5cc88b8.js"><link rel="prefetch" href="/JavaCore/assets/js/27.5a7f3f72.js"><link rel="prefetch" href="/JavaCore/assets/js/28.a5c1dfc9.js"><link rel="prefetch" href="/JavaCore/assets/js/29.7f19c13e.js"><link rel="prefetch" href="/JavaCore/assets/js/3.046617c7.js"><link rel="prefetch" href="/JavaCore/assets/js/30.9eda9a01.js"><link rel="prefetch" href="/JavaCore/assets/js/31.4fd367a3.js"><link rel="prefetch" href="/JavaCore/assets/js/32.02b9b683.js"><link rel="prefetch" href="/JavaCore/assets/js/33.3d407681.js"><link rel="prefetch" href="/JavaCore/assets/js/34.b41236d3.js"><link rel="prefetch" href="/JavaCore/assets/js/35.46feef49.js"><link rel="prefetch" href="/JavaCore/assets/js/36.7d4b5669.js"><link rel="prefetch" href="/JavaCore/assets/js/37.d25f11ea.js"><link rel="prefetch" href="/JavaCore/assets/js/38.f22f5ab0.js"><link rel="prefetch" href="/JavaCore/assets/js/39.df5ee31c.js"><link rel="prefetch" href="/JavaCore/assets/js/4.c83a1c34.js"><link rel="prefetch" href="/JavaCore/assets/js/40.525e113b.js"><link rel="prefetch" href="/JavaCore/assets/js/41.cddbe633.js"><link rel="prefetch" href="/JavaCore/assets/js/42.1e438b80.js"><link rel="prefetch" href="/JavaCore/assets/js/43.febd76a5.js"><link rel="prefetch" href="/JavaCore/assets/js/44.7f87cee9.js"><link rel="prefetch" href="/JavaCore/assets/js/45.8d61377c.js"><link rel="prefetch" href="/JavaCore/assets/js/46.18aebce3.js"><link rel="prefetch" href="/JavaCore/assets/js/47.5088be63.js"><link rel="prefetch" href="/JavaCore/assets/js/48.69473d1a.js"><link rel="prefetch" href="/JavaCore/assets/js/49.d2efec80.js"><link rel="prefetch" href="/JavaCore/assets/js/5.1f838002.js"><link rel="prefetch" href="/JavaCore/assets/js/50.aadca120.js"><link rel="prefetch" href="/JavaCore/assets/js/51.5803f7f2.js"><link rel="prefetch" href="/JavaCore/assets/js/52.daaa1b04.js"><link rel="prefetch" href="/JavaCore/assets/js/53.8500fd5e.js"><link rel="prefetch" href="/JavaCore/assets/js/54.0fb86c99.js"><link rel="prefetch" href="/JavaCore/assets/js/55.84bfb455.js"><link rel="prefetch" href="/JavaCore/assets/js/56.1c311c57.js"><link rel="prefetch" href="/JavaCore/assets/js/57.5b86dea5.js"><link rel="prefetch" href="/JavaCore/assets/js/58.98e4c3fa.js"><link rel="prefetch" href="/JavaCore/assets/js/59.de3f9828.js"><link rel="prefetch" href="/JavaCore/assets/js/6.df6c0997.js"><link rel="prefetch" href="/JavaCore/assets/js/60.0394a173.js"><link rel="prefetch" href="/JavaCore/assets/js/61.22019e53.js"><link rel="prefetch" href="/JavaCore/assets/js/62.2ad3a891.js"><link rel="prefetch" href="/JavaCore/assets/js/63.d2471b50.js"><link rel="prefetch" href="/JavaCore/assets/js/64.5c66ac60.js"><link rel="prefetch" href="/JavaCore/assets/js/65.1124d1dc.js"><link rel="prefetch" href="/JavaCore/assets/js/66.76d430c7.js"><link rel="prefetch" href="/JavaCore/assets/js/67.25fe71ce.js"><link rel="prefetch" href="/JavaCore/assets/js/68.5a9a18b1.js"><link rel="prefetch" href="/JavaCore/assets/js/69.a6686601.js"><link rel="prefetch" href="/JavaCore/assets/js/7.7349be35.js"><link rel="prefetch" href="/JavaCore/assets/js/70.a4fab40c.js"><link rel="prefetch" href="/JavaCore/assets/js/71.d9f3391e.js"><link rel="prefetch" href="/JavaCore/assets/js/72.2d18ca66.js"><link rel="prefetch" href="/JavaCore/assets/js/73.e9600bca.js"><link rel="prefetch" href="/JavaCore/assets/js/74.9fdebd15.js"><link rel="prefetch" href="/JavaCore/assets/js/75.41e339f7.js"><link rel="prefetch" href="/JavaCore/assets/js/76.837d8ab0.js"><link rel="prefetch" href="/JavaCore/assets/js/77.80e8e41b.js"><link rel="prefetch" href="/JavaCore/assets/js/78.8b802ab7.js"><link rel="prefetch" href="/JavaCore/assets/js/79.e8c07b67.js"><link rel="prefetch" href="/JavaCore/assets/js/8.49eea5b1.js"><link rel="prefetch" href="/JavaCore/assets/js/80.9bf88a6f.js"><link rel="prefetch" href="/JavaCore/assets/js/81.e555a891.js"><link rel="prefetch" href="/JavaCore/assets/js/82.8166fa2d.js"><link rel="prefetch" href="/JavaCore/assets/js/83.42d6ed2a.js"><link rel="prefetch" href="/JavaCore/assets/js/84.2a7891a5.js"><link rel="prefetch" href="/JavaCore/assets/js/85.5be9849a.js"><link rel="prefetch" href="/JavaCore/assets/js/86.7a7a9e12.js"><link rel="prefetch" href="/JavaCore/assets/js/87.6aef9807.js"><link rel="prefetch" href="/JavaCore/assets/js/88.1c5b0a37.js"><link rel="prefetch" href="/JavaCore/assets/js/89.fe008ebb.js"><link rel="prefetch" href="/JavaCore/assets/js/9.e8631032.js"><link rel="prefetch" href="/JavaCore/assets/js/90.376d33c9.js"><link rel="prefetch" href="/JavaCore/assets/js/91.15c5fbe3.js"><link rel="prefetch" href="/JavaCore/assets/js/92.e9fc8ac6.js"><link rel="prefetch" href="/JavaCore/assets/js/93.b7f62797.js"><link rel="prefetch" href="/JavaCore/assets/js/94.1d3a0306.js"><link rel="prefetch" href="/JavaCore/assets/js/95.3a200e03.js"><link rel="prefetch" href="/JavaCore/assets/js/96.051004dc.js"><link rel="prefetch" href="/JavaCore/assets/js/97.226de7d4.js"><link rel="prefetch" href="/JavaCore/assets/js/98.b529ae69.js"><link rel="prefetch" href="/JavaCore/assets/js/99.9d41538a.js">
    <link rel="stylesheet" href="/JavaCore/assets/css/0.styles.cc85f9e9.css">
  </head>
  <body class="theme-mode-light">
    <div id="app" data-server-rendered="true"><div class="theme-container sidebar-open have-rightmenu"><header class="navbar blur"><div title="目录" class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/JavaCore/" class="home-link router-link-active"><img src="/JavaCore/img/logo.png" alt="Yangzhou's blog" class="logo"> <span class="site-name can-hide">Yangzhou's blog</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/JavaCore/" class="nav-link">🏡首页</a></div><div class="nav-item"><a href="/JavaCore/guide/" class="nav-link">🔎导航</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="后端" class="dropdown-title"><a href="/JavaCore/web/" class="link-title">后端</a> <span class="title" style="display:none;">后端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>学习笔记</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/JavaCore/note/java/" class="nav-link">Java基础</a></li><li class="dropdown-subitem"><a href="/JavaCore/note/list/" class="nav-link">容器</a></li><li class="dropdown-subitem"><a href="/JavaCore/note/IO/" class="nav-link">IO</a></li><li class="dropdown-subitem"><a href="/JavaCore/note/concurrence/" class="nav-link">并发</a></li><li class="dropdown-subitem"><a href="/JavaCore/pages/e0e559/" class="nav-link">数据算法</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="数据库" class="dropdown-title"><a href="/JavaCore/sql/" class="link-title">数据库</a> <span class="title" style="display:none;">数据库</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>数据库基础和原理</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/JavaCore/pages/ef2a3c/" class="nav-link">数据库原理</a></li><li class="dropdown-subitem"><a href="/JavaCore/pages/ae8aaa/" class="nav-link">SQL语言</a></li></ul></li><li class="dropdown-item"><h4>SQL数据库</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/JavaCore/pages/661e9c/" class="nav-link">MySQL</a></li><li class="dropdown-subitem"><a href="/JavaCore/note/SpringMVC/" class="nav-link"></a></li></ul></li><li class="dropdown-item"><h4>NoSQL数据库</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/JavaCore/pages/8143cc480faf9a11/" class="nav-link"></a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="框架" class="dropdown-title"><!----> <span class="title" style="display:;">框架</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>Spring框架</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/JavaCore/pages/d43ed2/" class="nav-link">Spring5</a></li><li class="dropdown-subitem"><a href="/JavaCore/pages/123407/" class="nav-link">SpringMVC</a></li></ul></li><li class="dropdown-item"><h4>SpringBoot</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/JavaCore/pages/b36791/" class="nav-link">♥SpringBoot 知识体系详解♥</a></li><li class="dropdown-subitem"><a href="/JavaCore/pages/0950b1/" class="nav-link">SpringBoot入门</a></li><li class="dropdown-subitem"><a href="/JavaCore/pages/4b305a/" class="nav-link">SpringBoot接口设计和实现</a></li><li class="dropdown-subitem"><a href="/JavaCore/pages/6bd46a/" class="nav-link">SpringBoot集成数据库</a></li></ul></li><li class="dropdown-item"><h4>SpringBoot2</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/JavaCore/pages/194038/" class="nav-link">SpringBoot基础篇</a></li></ul></li><li class="dropdown-item"><h4>数据库</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/JavaCore/frame/MyBatis/" class="nav-link">MyBatis</a></li><li class="dropdown-subitem"><a href="/JavaCore/frame/MyBatis-Plus/" class="nav-link">MyBatis-Plus</a></li></ul></li><li class="dropdown-item"><h4>中间件</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/JavaCore/frame/Redis/" class="nav-link">Redis</a></li><li class="dropdown-subitem"><a href="/JavaCore/frame/RabbitMQ/" class="nav-link">RabbitMQ</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="🛠️工具|部署" class="dropdown-title"><!----> <span class="title" style="display:;">🛠️工具|部署</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4></h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/JavaCore/note/java/" class="nav-link">Git</a></li><li class="dropdown-subitem"><a href="/JavaCore/note/SpringMVC/" class="nav-link">Docker</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="📚项目" class="dropdown-title"><!----> <span class="title" style="display:;">📚项目</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4></h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/JavaCore/project/guli/" class="nav-link">🏫谷粒学院</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="🔖面经" class="dropdown-title"><!----> <span class="title" style="display:;">🔖面经</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4></h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/JavaCore/pages/3c0dd9/" class="nav-link">备战面试</a></li><li class="dropdown-subitem"><a href="/JavaCore/pages/cd85af/" class="nav-link">Java</a></li><li class="dropdown-subitem"><a href="/JavaCore/pages/6ce629/" class="nav-link">常用框架</a></li></ul></li></ul></div></div><div class="nav-item"><a href="/JavaCore/article/" class="nav-link">📖文章</a></div><div class="nav-item"><a href="/JavaCore/pages/8b8ebb/" class="nav-link">刷题</a></div> <a href="https://github.com/MrYz0" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar-hover-trigger"></div> <aside class="sidebar" style="display:none;"><div class="blogger"><img src="img/头像.jpg"> <div class="blogger-info"><h3>杨洲</h3> <span>后端界的小白</span></div></div> <nav class="nav-links"><div class="nav-item"><a href="/JavaCore/" class="nav-link">🏡首页</a></div><div class="nav-item"><a href="/JavaCore/guide/" class="nav-link">🔎导航</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="后端" class="dropdown-title"><a href="/JavaCore/web/" class="link-title">后端</a> <span class="title" style="display:none;">后端</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>学习笔记</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/JavaCore/note/java/" class="nav-link">Java基础</a></li><li class="dropdown-subitem"><a href="/JavaCore/note/list/" class="nav-link">容器</a></li><li class="dropdown-subitem"><a href="/JavaCore/note/IO/" class="nav-link">IO</a></li><li class="dropdown-subitem"><a href="/JavaCore/note/concurrence/" class="nav-link">并发</a></li><li class="dropdown-subitem"><a href="/JavaCore/pages/e0e559/" class="nav-link">数据算法</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="数据库" class="dropdown-title"><a href="/JavaCore/sql/" class="link-title">数据库</a> <span class="title" style="display:none;">数据库</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>数据库基础和原理</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/JavaCore/pages/ef2a3c/" class="nav-link">数据库原理</a></li><li class="dropdown-subitem"><a href="/JavaCore/pages/ae8aaa/" class="nav-link">SQL语言</a></li></ul></li><li class="dropdown-item"><h4>SQL数据库</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/JavaCore/pages/661e9c/" class="nav-link">MySQL</a></li><li class="dropdown-subitem"><a href="/JavaCore/note/SpringMVC/" class="nav-link"></a></li></ul></li><li class="dropdown-item"><h4>NoSQL数据库</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/JavaCore/pages/8143cc480faf9a11/" class="nav-link"></a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="框架" class="dropdown-title"><!----> <span class="title" style="display:;">框架</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4>Spring框架</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/JavaCore/pages/d43ed2/" class="nav-link">Spring5</a></li><li class="dropdown-subitem"><a href="/JavaCore/pages/123407/" class="nav-link">SpringMVC</a></li></ul></li><li class="dropdown-item"><h4>SpringBoot</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/JavaCore/pages/b36791/" class="nav-link">♥SpringBoot 知识体系详解♥</a></li><li class="dropdown-subitem"><a href="/JavaCore/pages/0950b1/" class="nav-link">SpringBoot入门</a></li><li class="dropdown-subitem"><a href="/JavaCore/pages/4b305a/" class="nav-link">SpringBoot接口设计和实现</a></li><li class="dropdown-subitem"><a href="/JavaCore/pages/6bd46a/" class="nav-link">SpringBoot集成数据库</a></li></ul></li><li class="dropdown-item"><h4>SpringBoot2</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/JavaCore/pages/194038/" class="nav-link">SpringBoot基础篇</a></li></ul></li><li class="dropdown-item"><h4>数据库</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/JavaCore/frame/MyBatis/" class="nav-link">MyBatis</a></li><li class="dropdown-subitem"><a href="/JavaCore/frame/MyBatis-Plus/" class="nav-link">MyBatis-Plus</a></li></ul></li><li class="dropdown-item"><h4>中间件</h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/JavaCore/frame/Redis/" class="nav-link">Redis</a></li><li class="dropdown-subitem"><a href="/JavaCore/frame/RabbitMQ/" class="nav-link">RabbitMQ</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="🛠️工具|部署" class="dropdown-title"><!----> <span class="title" style="display:;">🛠️工具|部署</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4></h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/JavaCore/note/java/" class="nav-link">Git</a></li><li class="dropdown-subitem"><a href="/JavaCore/note/SpringMVC/" class="nav-link">Docker</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="📚项目" class="dropdown-title"><!----> <span class="title" style="display:;">📚项目</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4></h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/JavaCore/project/guli/" class="nav-link">🏫谷粒学院</a></li></ul></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="🔖面经" class="dropdown-title"><!----> <span class="title" style="display:;">🔖面经</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><h4></h4> <ul class="dropdown-subitem-wrapper"><li class="dropdown-subitem"><a href="/JavaCore/pages/3c0dd9/" class="nav-link">备战面试</a></li><li class="dropdown-subitem"><a href="/JavaCore/pages/cd85af/" class="nav-link">Java</a></li><li class="dropdown-subitem"><a href="/JavaCore/pages/6ce629/" class="nav-link">常用框架</a></li></ul></li></ul></div></div><div class="nav-item"><a href="/JavaCore/article/" class="nav-link">📖文章</a></div><div class="nav-item"><a href="/JavaCore/pages/8b8ebb/" class="nav-link">刷题</a></div> <a href="https://github.com/MrYz0" target="_blank" rel="noopener noreferrer" class="repo-link">
    GitHub
    <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav>  <ul class="sidebar-links"><li><a href="/JavaCore/pages/4f5fec/" aria-current="page" class="active sidebar-link">Java并发简介</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level2"><a href="/JavaCore/pages/4f5fec/#并发的概念" class="sidebar-link">并发的概念</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/JavaCore/pages/4f5fec/#并发和并行" class="sidebar-link">并发和并行</a></li><li class="sidebar-sub-header level3"><a href="/JavaCore/pages/4f5fec/#同步和异步" class="sidebar-link">同步和异步</a></li><li class="sidebar-sub-header level3"><a href="/JavaCore/pages/4f5fec/#阻塞和非阻塞" class="sidebar-link">阻塞和非阻塞</a></li><li class="sidebar-sub-header level3"><a href="/JavaCore/pages/4f5fec/#进程和线程" class="sidebar-link">进程和线程</a></li><li class="sidebar-sub-header level3"><a href="/JavaCore/pages/4f5fec/#竞态条件和临界区" class="sidebar-link">竞态条件和临界区</a></li><li class="sidebar-sub-header level3"><a href="/JavaCore/pages/4f5fec/#管程" class="sidebar-link">管程</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/JavaCore/pages/4f5fec/#并发的特点" class="sidebar-link">并发的特点</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/JavaCore/pages/4f5fec/#提升资源利用率" class="sidebar-link">提升资源利用率</a></li><li class="sidebar-sub-header level3"><a href="/JavaCore/pages/4f5fec/#程序响应更快" class="sidebar-link">程序响应更快</a></li><li class="sidebar-sub-header level3"><a href="/JavaCore/pages/4f5fec/#并发的问题" class="sidebar-link">并发的问题</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/JavaCore/pages/4f5fec/#安全性问题" class="sidebar-link">安全性问题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/JavaCore/pages/4f5fec/#缓存导致的可见性问题" class="sidebar-link">缓存导致的可见性问题</a></li><li class="sidebar-sub-header level3"><a href="/JavaCore/pages/4f5fec/#线程切换带来的原子性问题" class="sidebar-link">线程切换带来的原子性问题</a></li><li class="sidebar-sub-header level3"><a href="/JavaCore/pages/4f5fec/#编译优化带来的有序性问题" class="sidebar-link">编译优化带来的有序性问题</a></li><li class="sidebar-sub-header level3"><a href="/JavaCore/pages/4f5fec/#保证并发安全的思路" class="sidebar-link">保证并发安全的思路</a></li><li class="sidebar-sub-header level4"><a href="/JavaCore/pages/4f5fec/#互斥同步-阻塞同步" class="sidebar-link">互斥同步（阻塞同步）</a></li><li class="sidebar-sub-header level4"><a href="/JavaCore/pages/4f5fec/#非阻塞同步" class="sidebar-link">非阻塞同步</a></li><li class="sidebar-sub-header level4"><a href="/JavaCore/pages/4f5fec/#无同步" class="sidebar-link">无同步</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/JavaCore/pages/4f5fec/#活跃性问题" class="sidebar-link">活跃性问题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/JavaCore/pages/4f5fec/#死锁-deadlock" class="sidebar-link">死锁（Deadlock）</a></li><li class="sidebar-sub-header level4"><a href="/JavaCore/pages/4f5fec/#什么是死锁" class="sidebar-link">什么是死锁</a></li><li class="sidebar-sub-header level4"><a href="/JavaCore/pages/4f5fec/#避免死锁" class="sidebar-link">避免死锁</a></li><li class="sidebar-sub-header level3"><a href="/JavaCore/pages/4f5fec/#活锁-livelock" class="sidebar-link">活锁（Livelock）</a></li><li class="sidebar-sub-header level4"><a href="/JavaCore/pages/4f5fec/#什么是活锁" class="sidebar-link">什么是活锁</a></li><li class="sidebar-sub-header level4"><a href="/JavaCore/pages/4f5fec/#避免活锁" class="sidebar-link">避免活锁</a></li><li class="sidebar-sub-header level3"><a href="/JavaCore/pages/4f5fec/#饥饿-starvation" class="sidebar-link">饥饿（Starvation）</a></li><li class="sidebar-sub-header level4"><a href="/JavaCore/pages/4f5fec/#什么是饥饿" class="sidebar-link">什么是饥饿</a></li><li class="sidebar-sub-header level4"><a href="/JavaCore/pages/4f5fec/#解决饥饿" class="sidebar-link">[#](https://dunwu.github.io/javacore/pages/f6b642/#解决饥饿)解决饥饿</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/JavaCore/pages/4f5fec/#性能问题" class="sidebar-link">性能问题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header level3"><a href="/JavaCore/pages/4f5fec/#上下文切换" class="sidebar-link">上下文切换</a></li><li class="sidebar-sub-header level4"><a href="/JavaCore/pages/4f5fec/#什么是上下文切换" class="sidebar-link">什么是上下文切换？</a></li><li class="sidebar-sub-header level4"><a href="/JavaCore/pages/4f5fec/#减少上下文切换的方法" class="sidebar-link">减少上下文切换的方法</a></li><li class="sidebar-sub-header level3"><a href="/JavaCore/pages/4f5fec/#资源限制" class="sidebar-link">资源限制</a></li><li class="sidebar-sub-header level4"><a href="/JavaCore/pages/4f5fec/#什么是资源限制" class="sidebar-link">什么是资源限制</a></li><li class="sidebar-sub-header level4"><a href="/JavaCore/pages/4f5fec/#资源限制引发的问题" class="sidebar-link">资源限制引发的问题</a></li><li class="sidebar-sub-header level4"><a href="/JavaCore/pages/4f5fec/#如何解决资源限制的问题" class="sidebar-link">如何解决资源限制的问题</a></li></ul></li><li class="sidebar-sub-header level2"><a href="/JavaCore/pages/4f5fec/#小结" class="sidebar-link">小结</a></li></ul></li><li><a href="/JavaCore/pages/98dd93/" class="sidebar-link">Java线程基础</a></li><li><a href="/JavaCore/pages/4a63d4/" class="sidebar-link">Java并发核心机制</a></li><li><a href="/JavaCore/pages/245f0b/" class="sidebar-link">Java锁</a></li><li><a href="/JavaCore/pages/d1a24f/" class="sidebar-link">Java原子类</a></li><li><a href="/JavaCore/pages/4b1829/" class="sidebar-link">Java并发和容器</a></li><li><a href="/JavaCore/pages/c8a6f2/" class="sidebar-link">Java线程池</a></li><li><a href="/JavaCore/pages/e3dbd5/" class="sidebar-link">Java并发工具类</a></li><li><a href="/JavaCore/pages/d6b637/" class="sidebar-link">Java内存模型</a></li><li><a href="/JavaCore/pages/383d80/" class="sidebar-link">ForkJoin框架</a></li><li><a href="/JavaCore/pages/4f43e3/" class="sidebar-link">Synchronized</a></li></ul> </aside> <div><main class="page"><div class="theme-vdoing-wrapper "><div class="articleInfo-wrap" data-v-06225672><div class="articleInfo" data-v-06225672><ul class="breadcrumbs" data-v-06225672><li data-v-06225672><a href="/JavaCore/" title="首页" class="iconfont icon-home router-link-active" data-v-06225672></a></li> <li data-v-06225672><a href="/JavaCore/note/concurrence/#并发" data-v-06225672>并发</a></li></ul> <div class="info" data-v-06225672><div title="作者" class="author iconfont icon-touxiang" data-v-06225672><a href="https://github.com/xugaoyi" target="_blank" title="作者" class="beLink" data-v-06225672>杨洲</a></div> <div title="创建时间" class="date iconfont icon-riqi" data-v-06225672><a href="javascript:;" data-v-06225672>2022-08-07</a></div> <!----></div></div></div> <!----> <div class="content-wrapper"><div class="right-menu-wrapper"><div class="right-menu-margin"><div class="right-menu-title">目录</div> <div class="right-menu-content"></div></div></div> <h1><img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAB4AAAAeCAYAAAA7MK6iAAAAAXNSR0IArs4c6QAABGpJREFUSA3tVVtoXFUU3fvOI53UlmCaKIFmwEhsE7QK0ipFEdHEKpXaZGrp15SINsXUWvBDpBgQRKi0+KKoFeJHfZA+ED9KKoIU2gYD9UejTW4rVIzm0VSTziPzuNu1z507dibTTjL4U/DAzLn3nL3X2o91ziX6f9wMFdh6Jvbm9nNSV0msViVO6tN1Rm7NMu2OpeJ9lWBUTDxrJbYTS0hInuwciu9eLHlFxCLCZEk3MegsJmZ5K/JD6t7FkFdEvGUo1g7qJoG3MHImqRIn8/nzY1K9UPKKiJmtnUqHVE3Gbuay6vJE/N2FEmuxFjW2nUuE0yQXRRxLiTUAzs36zhZvOXJPdX850EVnnLZkB8prodQoM5JGj7Xk2mvC7JB8tG04Ef5PiXtG0UtxupRQSfTnBoCy554x18yJHI6I+G5Eru4LHmPJZEQsrvPUbMiA8G/WgMK7w7I+ez7++o2ANfbrjvaOl1tFMs+htG3IrZH9/hDX1Pr8Tc0UvH8tcX29KzAgIGcEkINyW5BF9x891hw6VYqgJHEk0huccS7vh3C6gTiODL+26huuBtbct8eZnqLML8PkxGYpuPZBqtqwkSjgc4mB5gbgig5i+y0UDK35LMxXisn9xQtK+nd26gTIHsHe/oblK/b29fUmN/8Y+9jAQrnBp56m1LcDlDp9irKTExSKduXJVWSqdBMA08pEJnEIOB3FPPMybu/oeV8zFeYN3xx576Q6RH+VmplE4ncQV5v+5rzSoyOU7PuEAg8g803PwBJ0CExno/jcMbN8tONYeOmHiuUNryvm3fRUy4tMPVLdAGkUhNWuggGrJcXPv+ouCjz0MKUHz1J2/E8IC9nqTabcxgaBYM0hPhD5Y65FsbxRQKxCQrDjDctW7PUM3HuZunFyifSAqEfuzCp48Il24luWUWZoyJCaPR82jE0+kFA643wRFVni4RYSq3ohJO2pZ7B5dO4xkDWbEpossJPLSrPjYID8rS2UHTlvyNxqIGsg674XJJ7vnh5L7PNwC4hh2sjCI96mzszOTpxLF0T7l88Yz7lAuK6OnL8gXLOnTvpzSb22YG8W7us3jSebFHeeqnXRG1vt+MoUM84LQIBmMsCTAcOauTh0T0l0neQK7m2bLMt2mGxU3HYssS0J2cdv5wljlPsrIuZLAG/2DOZIXgCYT8uMGZN+e2kSirfxZOPCsC0f24nTZzspnVn9VePS1Z5vubmAGGXG8ZFno9Hel0yfA5ZPhF7Dh972BQJ2qCpgH67lmWtBYbvk6sz02wjky2vXyz0XErP/kFB619js1BtwfOV4OPRqOQBjy3Qbk18vigUPPSD5ceHnwck7W9bhAqZdd7SuG7w4/P2F/GaJh8c7e9qgow+Q7cGBo+98WsLkuktFqiZabtXuQTu/Y5ETbR0v7tNSFnvrmu6pjdoan2KjMu8q/Hmj1EfCO2ZGfEIbIXKUlw8qaX9/b2oeSJmFksSeT/Fn0V3nSypChh4Gjh74ybO9aeZ/AN2dwciu2/MhAAAAAElFTkSuQmCC">Java并发简介<!----></h1>  <div class="theme-vdoing-content content__default"><blockquote><p><strong>关键词：</strong><code>进程</code>、<code>线程</code>、<code>安全性</code>、<code>活跃性</code>、<code>性能</code>、<code>死锁</code>、<code>饥饿</code>、<code>上下文切换</code></p> <p><strong>摘要：</strong> 并发编程并非Java语言所独有，而是一种成熟的编程规范，Java只是用自己的方式实现了并发工作模型。学习Java并发编程，应该先熟悉并发的基本概念，然后进一步了解并发的特性以及特性所面临的问题。掌握了这些，当学习Java并发工具时，才会明白它们各自是为了解决什么问题，为什么要这样设计。通过这样由点到面的学习方式，更容易融会贯通，将并发知识形成体系化。</p></blockquote> <p><img src="http://yz-typora-img.oss-cn-shanghai.aliyuncs.com/img/image-20220809092742883.png" alt="image-20220809092742883"></p> <h2 id="并发的概念"><a href="#并发的概念" class="header-anchor">#</a> 并发的概念</h2> <p>并发编程中有很多术语概念相近，容易让人混淆。本节内容通过对比分析，力求让读者清晰理解其概念以及差异。</p> <h3 id="并发和并行"><a href="#并发和并行" class="header-anchor">#</a> 并发和并行</h3> <p>并发和并行是最容易让新手费解的概念，那么如何理解二者呢？其最关键的差异在于：是否是<strong>同时</strong>发送：</p> <ul><li><strong>并发：</strong> 是指具备处理多个任务的能力，但不一定要同时。</li> <li><strong>并行：</strong> 是指具备同时处理多个任务的能力。</li></ul> <p>下面是用一个生动的栗子说明：</p> <ul><li>你吃饭吃到一半，电话来了，你一直到吃完以后才去接，这就说明你不支持并发也不支持并行。</li> <li>你吃饭吃到一半，电话来了，你停了下来接了电话，接完后继续吃饭，这就说宁你支持并发。</li> <li>你吃饭吃到一半，电话来了，你一边打电话一边吃饭，这就说明你支持并行。</li></ul> <h3 id="同步和异步"><a href="#同步和异步" class="header-anchor">#</a> 同步和异步</h3> <ul><li><strong>同步：</strong> 是指在发出一个调用时，在没有得到结果之前，该调用就不返回。但是一旦调用返回，就得到返回值了。</li> <li><strong>异步：</strong> 则是相反，调用在发出之后，这个调用就直接返回了，所以没有返回结果。换句话说，当一个异步过程调用发出后，调用者不会立刻得到结果。而是在调用发出后，被调用者通过状态、通知来通知调用者，或通过回调函数处理这个回调。</li></ul> <p>举栗说明：</p> <ul><li>同步就像是打电话：不挂电话，通话就不会结束。</li> <li>异步就像是发短信：发完短信后，就可以做其他事；当收到回复短信时，手机会通过铃声或振动来提醒。</li></ul> <h3 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="header-anchor">#</a> 阻塞和非阻塞</h3> <p>阻塞和非阻塞关注的是程序在等待调用结果（消息，返回值）时的状态：</p> <ul><li><strong>阻塞：</strong> 是指调用结果返回之前，当前线程会被挂起。调用线程只有在得到结果之后才会返回。</li> <li>**非阻塞： ** 是指在不能立刻得到结果之前，该调用不会阻塞当前程序。</li></ul> <p>举栗来说明：</p> <ul><li>阻塞调用就像是打电话，通话不结束，不能放下。</li> <li>非阻塞调用就像发短信，发完短信后，就可以做其他事，短信来了，手机会提醒。</li></ul> <h3 id="进程和线程"><a href="#进程和线程" class="header-anchor">#</a> 进程和线程</h3> <ul><li><strong>进程：</strong> 进程是具有一定独立功能的程序关于某个数据集合上的一次运行活动。进程是操作系统进行资源分配的基本单位。进程可视为一个正在运行的程序。</li> <li><strong>线程：</strong> 线程是操作系统进行调度的基本单位。</li></ul> <p>进程和线程的差异：</p> <ul><li>一个程序至少有一个进程，一个进程至少有一个线程。</li> <li>线程比进程划分更细，所以执行开销更小，并发性更高</li> <li>进程是一个实体，拥有独立的资源；而同一个进程中的多个线程共享进程的资源。</li></ul> <p><img src="http://yz-typora-img.oss-cn-shanghai.aliyuncs.com/img/image-20220809094501382.png" alt="image-20220809094501382"></p> <p>JVM 在单个进程中运行，JVM 中的线程共享属于该进程的堆。这就是为什么几个线程可以访问同一个对象。线程共享堆并拥有自己的堆栈空间。这是一个线程如何调用一个方法以及它的局部变量是如何保持线程安全的。但是堆不是线程安全的并且为了线程安全必须进行同步。</p> <h3 id="竞态条件和临界区"><a href="#竞态条件和临界区" class="header-anchor">#</a> 竞态条件和临界区</h3> <ul><li><strong>竞态条件（Race Condition）</strong>：当两个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件。</li> <li><strong>临界区（Critical Sections）</strong>：导致竞态条件发生的代码区称作临界区。</li></ul> <h3 id="管程"><a href="#管程" class="header-anchor">#</a> 管程</h3> <p>管程（Monitor），是指管理共享变量以及对共享变量的操作过程，让他们支持并发。</p> <p>Java 采用的是管程技术，synchronized 关键字及 wait()、notify()、notifyAll() 这三个方法都是管程的组成部分。而<strong>管程和信号量是等价的，所谓等价指的是用管程能够实现信号量，也能用信号量实现管程</strong>。</p> <h2 id="并发的特点"><a href="#并发的特点" class="header-anchor">#</a> 并发的特点</h2> <p>技术在进步，CPU、内存、I/O设备的性能也在不断提高。但是，始终存在一个核心矛盾：**CPU、内存、I/O设备存在速度差异。**CPU远快于内存，内存远快于I/O设备。</p> <p>木桶短板理论告诉我们：一致木桶能装多少水，取决于最短的那块木板。同理，程序整体性能取决于最慢的操作（即I/O操作），所以单方面提高CPU、内存的性能是无效的。</p> <p><img src="http://yz-typora-img.oss-cn-shanghai.aliyuncs.com/img/image-20220809094807302.png" alt="image-20220809094807302"></p> <p>为了合理利用CPU的高性能，平衡这三者的速度差异，计算机体系结构、操作系统、编译程序都作出了贡献，主要体现在：</p> <ul><li><strong>CPU增加了缓存，</strong> 以均衡与内存的速度差异；</li> <li><strong>操作系统增加了线程、进程，</strong> 以分时复用CPU，进而均衡CPU与I/O设备的速度差异；</li> <li><strong>编译程序优化指令执行次序，</strong> 是的缓存能够得到更加合理地利用。</li></ul> <p>其中，进程、线程使得计算机、程序有了并发处理任务的能力。</p> <p>并发的优点在于：</p> <ul><li>提升资源利用率</li> <li>程序响应更快</li></ul> <h3 id="提升资源利用率"><a href="#提升资源利用率" class="header-anchor">#</a> 提升资源利用率</h3> <p>想象一下，一个应用程序需要从本地文件系统中读取和处理文件的情景。比方说，从磁盘读取一个文件需要 5 秒，处理一个文件需要 2 秒。处理两个文件则需要：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token number">5</span>秒读取文件<span class="token class-name">A</span>
<span class="token number">2</span>秒处理文件<span class="token class-name">A</span>
<span class="token number">5</span>秒读取文件<span class="token class-name">B</span>
<span class="token number">2</span>秒处理文件<span class="token class-name">B</span>
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>
总共需要<span class="token number">14</span>秒
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>从磁盘中读取文件的时候，大部分的 CPU 时间用于等待磁盘去读取数据。在这段时间里，CPU 非常的空闲。它可以做一些别的事情。通过改变操作的顺序，就能够更好的使用 CPU 资源。看下面的顺序：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token number">5</span>秒读取文件<span class="token class-name">A</span>
<span class="token number">5</span>秒读取文件<span class="token class-name">B</span> <span class="token operator">+</span> <span class="token number">2</span>秒处理文件<span class="token class-name">A</span>
<span class="token number">2</span>秒处理文件<span class="token class-name">B</span>
<span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">--</span><span class="token operator">-</span>
总共需要<span class="token number">12</span>秒
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>CPU 等待第一个文件被读取完。然后开始读取第二个文件。当第二文件在被读取的时候，CPU 会去处理第一个文件。记住，在等待磁盘读取文件的时候，CPU 大 部分时间是空闲的。</p> <p>总的说来，CPU 能够在等待 IO 的时候做一些其他的事情。这个不一定就是磁盘 IO。它也可以是网络的 IO，或者用户输入。通常情况下，网络和磁盘的 IO 比 CPU 和内存的 IO 慢的多。</p> <h3 id="程序响应更快"><a href="#程序响应更快" class="header-anchor">#</a> 程序响应更快</h3> <p>将一个单线程应用程序变成多线程应用程序的另一个常见的目的是实现一个响应更快的应用程序。设想一个服务器应用，它在某一个端口监听进来的请求。当一个请求到来时，它去处理这个请求，然后再返回去监听。</p> <p>服务器的流程如下所述：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">while</span><span class="token punctuation">(</span>server is active<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    listen <span class="token keyword">for</span> request
    process request
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>如果一个请求需要占用大量的时间处理，在这段时间内新的客户端就无法发送请求给服务端。只有服务端在监听的时候，请求才能被接收。另一种设计是，监听线程把请求传递给工作者线程（worker thread），然后立刻返回去监听。而工作者线程则能够处理这个请求并发送一个回复给客户端。这种设计如下所述：</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">while</span><span class="token punctuation">(</span>server is active<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    listen <span class="token keyword">for</span> request
    hand request <span class="token keyword">to</span> <span class="token namespace">worker</span> thread
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>这种方式，服务端线程迅速地返回去监听。因此，更多的客户端能够发送请求给服务端。这个服务也变得响应更快。</p> <p>桌面应用也是同样如此。如果你点击一个按钮开始运行一个耗时的任务，这个线程既要执行任务又要更新窗口和按钮，那么在任务执行的过程中，这个应用程序看起来好像没有反应一样。相反，任务可以传递给工作者线程（worker thread)。当工作者线程在繁忙地处理任务的时候，窗口线程可以自由地响应其他用户的请求。当工作者线程完成任务的时候，它发送信号给窗口线程。窗口线程便可以更新应用程序窗口，并显示任务的结果。对用户而言，这种具有工作者线程设计的程序显得响应速度更快。</p> <h3 id="并发的问题"><a href="#并发的问题" class="header-anchor">#</a> 并发的问题</h3> <p>任何事物都有利弊，并发也不例外。</p> <p>我们知道了并发带来的好处：提升资源利用率、程序响应更快，同时也要认识到并发带来的问题，主要有：</p> <ul><li>安全性问题</li> <li>活跃性问题</li> <li>性能问题</li></ul> <p>下面会一一讲解</p> <h2 id="安全性问题"><a href="#安全性问题" class="header-anchor">#</a> 安全性问题</h2> <p>并发最重要的问题是并发安全问题。</p> <p>**并发安全：**是指保证程序的正确性，使得并发处理结果符合预期。</p> <p>并发安全需要保证几个基本特性：</p> <ul><li><strong>可见性：</strong> - 是一个线程修改了某个共享变量，其状态能够立即被其他线程知晓，通常被解释为将线程本地状态反映到主内存上，<code>volatile</code>就是负责保证可见性的。</li> <li><strong>原子性：</strong> - 简单来说就是相关操作不会中途被其他线程干扰，一般通过同步机制（枷锁：<code>sychronized</code>、<code>Lock</code>）实现。</li> <li><strong>有序性：</strong> - 是保证线程内串行语义，避免指令重排等。</li></ul> <h3 id="缓存导致的可见性问题"><a href="#缓存导致的可见性问题" class="header-anchor">#</a> 缓存导致的可见性问题</h3> <blockquote><p>一个线程对共享变量的修改，另外一个线程能够立刻看到，称为 <strong>可见性。</strong></p></blockquote> <p>      在单核时代，所有的线程都是在一颗CPU上执行，CPU缓存与内存的数据一致性容易解决。因为所有线程都是操作同一个CPU的缓存，一个线程对缓存的写，对另一个线程来说一定是可见的。例如在下图中，线程A和线程B都是操作同一个CPU里面的缓存，所以线程A更新了变量V的值，那么线程B之后再访问变量V，得到的一定是V的最新值（线程A写过的值）。</p> <p><img src="http://yz-typora-img.oss-cn-shanghai.aliyuncs.com/img/image-20220810094629619.png" alt="image-20220810094629619"></p> <p>      多核时代，每颗CPU都有自己的缓存，这时CPU缓存与内存的数据一致性就没有那么容易解决了，当多个线程在不同的CPU上执行时，这些线程操作的是不同的CPU缓存。比如下图中，线程A操作的是CPU-1上的缓存，而线程B操作的是CPU-2上的缓存，很明显。这个时候线程A对变量V的操作对于线程B而言就不具备可见性了。</p> <p><img src="http://yz-typora-img.oss-cn-shanghai.aliyuncs.com/img/image-20220810094933463.png" alt="image-20220810094933463"></p> <p>【示例】线程不安全的实例</p> <p>      下面我们再用一段代码来验证一下多核场景下的可见性问题。下面的代码，没执行一次add10K()方法，都会循环10000此count+=1操作。在calc()方法中我们创建了两个线程，每个线程调用一次add10K()方法，我们来想一想执行calc()方法得到的结果应该是什么呢？</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>
  <span class="token keyword">private</span> <span class="token keyword">long</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
  <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">add10K</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>idx<span class="token operator">++</span> <span class="token operator">&lt;</span> <span class="token number">10000</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      count <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token function">calc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">final</span> <span class="token class-name">Test</span> test <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 创建两个线程，执行 add() 操作</span>
    <span class="token class-name">Thread</span> th1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token punctuation">{</span>
      test<span class="token punctuation">.</span><span class="token function">add10K</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token class-name">Thread</span> th2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token punctuation">{</span>
      test<span class="token punctuation">.</span><span class="token function">add10K</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 启动两个线程</span>
    th1<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    th2<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">// 等待两个线程执行结束</span>
    th1<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    th2<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> count<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><p>      直接告诉我们应该是20000，因为在单线程里调用两次add10K()方法，count的值就是20000，但实际上calc()执行结果是个10000到20000的随机数，为什么呢？</p> <p>      我们假设线程A和线程B同时开始执行，那么第一次都会将count = 0读到各自的CPU缓存里，执行完count+=1之后，各自CPU缓存里的值都是1，同时写入内存后，我们会发现内存中是1，而不是我们期望的2。之后由于各自的CPU缓存里都有了count的值，两个线程都是基于CPU缓存里的count值来计算，所以导致最终count的值都是小于20000的。<span style="color:red;">这就是缓存的可见性问题。</span></p> <p>      循环10000此count+=1操作如果改为循环1亿次，你会发现效果更明显，最终count的值接近1亿，而不是2亿。如果循环10000次，count的值接近20000，原因是两个消除不是同时启动的，有一个时差。</p> <p><img src="http://yz-typora-img.oss-cn-shanghai.aliyuncs.com/img/image-20220810101804971.png" alt="image-20220810101804971"></p> <h3 id="线程切换带来的原子性问题"><a href="#线程切换带来的原子性问题" class="header-anchor">#</a> 线程切换带来的原子性问题</h3> <p>      由于 IO 太慢，早期的操作系统就发明了多进程，操作系统允许某个进程执行一小段时间（称为 <strong>时间片</strong>）。</p> <p>      在一个时间片内，如果一个线程进行一个IO操作，例如读个文件，这个时候该进程可以把自己标记为“休眠状态”并出让CPU的使用权，待文件读进内存，操作系统会把这个休眠的进程唤醒，唤醒后的进程就有机会重新获得CPU的使用权了。</p> <p>      这里的进程在等待IO时之所以会释放CPU的使用权，是为了让CPU在这段时间里可以做别的事情，这样一来CPU的使用率就上来了；此外，如果这时有另外一个进程也读文件，读文件的操作就会排队，磁盘驱动在完成一个进程的读操作后，发现有排队的任务，就会立即启动下一个操作，这样IO的使用率也上来了。</p> <p>      早期的操作系统基于进程来调度CPU的，不同进程间是不共享内存空间的，所以进程要做任务切换就要切换内存映射地址，而一个进程创建的所有线程，都是共享一个内存空间的，所以线程做任务切换成本就很低了。现代的操作系统都基于更轻量的线程来调度，现在我们提到的“任务切换”都是指“线程切换”。</p> <p>      Java并发查询都是基于多线程的，自然也会涉及到任务切换，也许你想不到，任务切换竟然也是并发程序里诡异BUG的源头之一。任务切换的时机大多数实在时间片结束的时候，我们想在基本都使用高级语言编程，高级语言里一条语句往往需要多条CPU指令完成，例如上面代码中的<code>count += 1</code>，至少需要三条CPU指令。</p> <ul><li>指令1：首先，需要把变量count从内存加载到CPU的寄存器；</li> <li>指令2：之后，在寄存器中执行+1操作；</li> <li>指令3：最后，将结果写入内存（缓存机制导致可能写入的是CPU缓存而不是内存）。</li></ul> <p>      操作系统做任务切换，可以发送在任何一条 <strong>CPU 指令</strong> 执行完，是的，是CPU指令，而不是高级语言里的一条语句。对于上面的三条指令来说，我们假设count=0，如果线程A在指令1执行完后做线程切换，线程A和线程B按照下图的序列执行，那么我们会发现两个线程都执行了count+=1的操作，但是得到的结果不是我们期望的2，而是1.</p> <p><img src="http://yz-typora-img.oss-cn-shanghai.aliyuncs.com/img/image-20220810105150738.png" alt="image-20220810105150738"></p> <p>      我们潜意识里面觉得count+=1这个操作是一个不可分割的整体，就像一个原子一样，线程的切换可以发送在count+=1之前，也可以发送在count+=1之后，但是就是不会发生在中间。<strong>我们把一个或多个操作在CPU执行的过程中不被中断的特性称为原子性。</strong> CPU能保证的原子操作是CPU指令级别的，而不是高级语言的操作符，这是违背我们直觉的地方。因此，很多时候我们需要在高级语言层面保证操作的原子性。</p> <h3 id="编译优化带来的有序性问题"><a href="#编译优化带来的有序性问题" class="header-anchor">#</a> 编译优化带来的有序性问题</h3> <p>      那并发编程里还有没有其他有违背直觉导致诡异BUG的技术呢？有的，就是有序性。顾名思义，有序性指的是程序按照代码的先后顺序执行。编译器为了优化性能，有时候会改变程序中语句的先后顺序，例如程序中：&quot;a=6;b=7&quot;;编译器优化后可能变成&quot;b=7;a=6&quot;，在这个例子中，编译器调整李语句的顺序，但是不影响程序的最终结果。不过有时候编译器及解释器的优化可能导致意想不到的BUG。</p> <p>      在Java领域一个经典的案例就是利用双重检查创建单例对象，例如下面的代码：在获取实例getInstance()的方法中，我们首先判断instance是否为空，如果为空，则锁定Singleton.class并再次检查instance是否为空，如果还为空则创建Singleton的一个实例。</p> <div class="language-java line-numbers-mode"><pre class="language-java"><code><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>
  <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance<span class="token punctuation">;</span>
  <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">synchronized</span><span class="token punctuation">(</span><span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span>
          instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> instance<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>      假设有两个线程A、B同时调用getInstance()方法，他们会同时发现<code>instance == null</code>，于是同时对Singleton.class加锁，此时JVM保证只有一个线程能够加锁成功（假设是线程A），另外一个线程则会处于等待状态（假设是线程B）；线程A会创建一个Aingleton实例，之后释放锁，锁释放后，线程B会被唤醒，线程B再次尝试加锁，此时是可以加锁成功的，加锁成功后，线程B检查<code>instance == null</code>时会发现，已经创建过Singleton实例了，所以线程B不会在创建一个Singleton实例。</p> <p>      这看上去一切都很完美，无懈可击，但实际上这个getInstance()方法并不完美。问题出在哪里呢？出在new操作上，我们以为的new操作应该是：</p> <ol><li>分配一块内存M；</li> <li>在内存,上初始化Singleton对象；</li> <li>然后M的地址赋值给instance变量。</li></ol> <p>但实际上优化后的执行路径却是这样的：</p> <ol><li>分配一块内存M；</li> <li>将M的地址赋值给instance变量；</li> <li>最后在内存M上初始化Singleton对象。</li></ol> <p>      优化后会导致什么问题呢？我们假设线程A先执行getInstance()方法，当执行完指令2时恰好发生了线程切换，切换到了线程B上；如果此线程B也执行了getInstance()方法，那么线程B在执行第一个判断时会发现<code>instance != null</code>，所以直接返回instance，而此时的instance是没有初始化过的，如果我们这个时候访问instance的成员变量就可能触发空指针异常。</p> <p><img src="http://yz-typora-img.oss-cn-shanghai.aliyuncs.com/img/image-20220810111229057.png" alt="image-20220810111229057"></p> <h3 id="保证并发安全的思路"><a href="#保证并发安全的思路" class="header-anchor">#</a> 保证并发安全的思路</h3> <h4 id="互斥同步-阻塞同步"><a href="#互斥同步-阻塞同步" class="header-anchor">#</a> 互斥同步（阻塞同步）</h4> <p>互斥同步是最常见的并发正确性保障手段。</p> <p><strong>同步是值在多线程并发访问共享数据时，保证共享数据在同一时刻只能被一个线程访问。</strong></p> <p>互斥是实现同步的一个手段。临界区（Critical Sections）、互斥量（Mutex）和信号量（Semaphore）都是主要的互斥实现方式。</p> <p>最典型的案例是使用 <code>synchronized</code> 或 <code>Lock</code> 。</p> <p>**互斥同步最主要的问题是多线程阻塞和唤醒所带来的性能问题，**互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁（这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁）、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。</p> <h4 id="非阻塞同步"><a href="#非阻塞同步" class="header-anchor">#</a> 非阻塞同步</h4> <p>随着硬件指令集的发展，我们可以使用基于冲突检测的乐观并发策略：先进性操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施（不断地重试，直到成功为止）。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。</p> <p>为什么说乐观锁需要 <strong>硬件指令集的发展</strong> 才能进行？因为需要操作和冲突检测这两个步骤具备原子性。而这点是由硬件来完成，如果再使用互斥同步来保证就失去意义了。</p> <p>这类乐观锁指令常见的有：</p> <ul><li>测试并设置（Test-and-Set）</li> <li>获取并增加（Fetch-and-Increment）</li> <li>交换（Swap）</li> <li>比较并交换（CAS）</li> <li>加载链接、条件存储（Load-linked / Store-Conditional）</li></ul> <p>Java 典型应用场景：J.U.C 包中的原子类（基于 <code>Unsafe</code> 类的 CAS 操作）</p> <h4 id="无同步"><a href="#无同步" class="header-anchor">#</a> 无同步</h4> <p>要保证线程安全，不一定非要进行同步。同步只是保证共享数据争用时的正确性，如果一个方法本来就不涉及共享数据，那么自然无须同步。</p> <p>Java 中的 <strong>无同步方案</strong> 有：</p> <ul><li><strong>可重入代码</strong> - 也叫纯代码。如果一个方法，它的 <strong>返回结果是可以预测的</strong>，即只要输入了相同的数据，就能返回相同的结果，那它就满足可重入性，当然也是线程安全的。</li> <li><strong>线程本地存储</strong> - 使用 <strong><code>ThreadLocal</code> 为共享变量在每个线程中都创建了一个本地副本</strong>，这个副本只能被当前线程访问，其他线程无法访问，那么自然是线程安全的。</li></ul> <h2 id="活跃性问题"><a href="#活跃性问题" class="header-anchor">#</a> 活跃性问题</h2> <h3 id="死锁-deadlock"><a href="#死锁-deadlock" class="header-anchor">#</a> 死锁（Deadlock）</h3> <h4 id="什么是死锁"><a href="#什么是死锁" class="header-anchor">#</a> 什么是死锁</h4> <p>多个线程互相等待对方释放锁。</p> <p><span style="color:red;">死锁是当线程进入无限期等待状态时发生的情况</span>，因为所请求的锁被另一个线程持有，而另一个线程又等待第一个线程持有的另一个锁。</p> <p><img src="http://yz-typora-img.oss-cn-shanghai.aliyuncs.com/img/image-20220811092149528.png" alt="image-20220811092149528"></p> <h4 id="避免死锁"><a href="#避免死锁" class="header-anchor">#</a> 避免死锁</h4> <p>（1）按序加锁</p> <p>当多个线程需要相同的一些锁，但是按照不同的顺序加锁，死锁就很容易发生。</p> <p>如果能确保所有的线程都是按照相同的顺序获得锁，那么死锁就不会发生。</p> <p>按照顺序加锁是一种有效的死锁预防机制。但是，这种方式需要你事先知道所有可能会用到的锁(译者注：并对这些锁做适当的排序)，但总有些时候是无法预知的。</p> <p>（2）超时释放锁</p> <p>另外一个可以避免死锁的方法是在尝试获取锁的时候加一个超时时间，这也就意味着在尝试获取锁的过程中若超过了这个时限该线程则放弃对该锁请求。若一个线程没有在给定的时限内成功获得所有需要的锁，则会进行回退并释放所有已经获得的锁，然后等待一段随机的时间再重试。这段随机的等待时间让其它线程有机会尝试获取相同的这些锁，并且让该应用在没有获得锁的时候可以继续运行(译者注：加锁超时后可以先继续运行干点其它事情，再回头来重复之前加锁的逻辑)。</p> <p>（3）死锁检测</p> <p>死锁检测是一个更好的死锁预防机制，它主要是针对那些不可能实现按序加锁并且锁超时也不可行的场景。</p> <p>每当一个线程获得了锁，会在线程和锁相关的数据结构中（map、graph 等等）将其记下。除此之外，每当有线程请求锁，也需要记录在这个数据结构中。</p> <p>当一个线程请求锁失败时，这个线程可以遍历锁的关系图看看是否有死锁发生。</p> <p>如果检测出死锁，有两种处理手段：</p> <ul><li>释放所有锁，回退，并且等待一段随机的时间后重试。这个和简单的加锁超时类似，不一样的是只有死锁已经发生了才回退，而不会是因为加锁的请求超时了。虽然有回退和等待，但是如果有大量的线程竞争同一批锁，它们还是会重复地死锁（编者注：原因同超时类似，不能从根本上减轻竞争）。</li> <li>一个更好的方案是给这些线程设置优先级，让一个（或几个）线程回退，剩下的线程就像没发生死锁一样继续保持着它们需要的锁。如果赋予这些线程的优先级是固定不变的，同一批线程总是会拥有更高的优先级。为避免这个问题，可以在死锁发生的时候设置随机的优先级。</li></ul> <h3 id="活锁-livelock"><a href="#活锁-livelock" class="header-anchor">#</a> 活锁（Livelock）</h3> <h4 id="什么是活锁"><a href="#什么是活锁" class="header-anchor">#</a> 什么是活锁</h4> <p><span style="color:red;">活锁是一个递归的情况，两个或更多的线程会不断重复一个特定的代码逻辑。</span>预期的逻辑通常为其他线程提供机会继续支持'this'线程。</p> <p>想象这样一个例子：两个人在狭窄的走廊里相遇，二者都很礼貌，试图移到旁边让对方先通过。但是他们最终在没有取得任何进展的情况下左右摇摆，因为他们都在同一时间向相同的方向移动。</p> <p><img src="http://yz-typora-img.oss-cn-shanghai.aliyuncs.com/img/image-20220811092227507.png" alt="image-20220811092227507"></p> <p>如图所示：两个线程想要通过一个 Worker 对象访问共享公共资源的情况，但是当他们看到另一个 Worker（在另一个线程上调用）也是“活动的”时，它们会尝试将该资源交给其他工作者并等待为它完成。如果最初我们让两名工作人员都活跃起来，他们将会面临活锁问题。</p> <h4 id="避免活锁"><a href="#避免活锁" class="header-anchor">#</a> 避免活锁</h4> <p>解决“<strong>活锁</strong>”的方案很简单，谦让时，尝试等待一个随机的时间就可以了。由于等待的时间是随机的，所以同时相撞后再次相撞的概率就很低了。“等待一个随机时间”的方案虽然很简单，却非常有效，Raft 这样知名的分布式一致性算法中也用到了它。</p> <h3 id="饥饿-starvation"><a href="#饥饿-starvation" class="header-anchor">#</a> 饥饿（Starvation）</h3> <h4 id="什么是饥饿"><a href="#什么是饥饿" class="header-anchor">#</a> 什么是饥饿</h4> <ul><li>高优先级线程吞噬所有的低优先级线程的 CPU 时间。</li> <li>线程被永久堵塞在一个等待进入同步块的状态，因为其他线程总是能在它之前持续地对该同步块进行访问。</li> <li>线程在等待一个本身(在其上调用 wait())也处于永久等待完成的对象，因为其他线程总是被持续地获得唤醒。</li></ul> <p><img src="http://yz-typora-img.oss-cn-shanghai.aliyuncs.com/img/image-20220811092256424.png" alt="image-20220811092256424"></p> <p>饥饿问题最经典的例子就是哲学家问题。如图所示：有五个哲学家用餐，每个人要获得两把叉子才可以就餐。当 2、4 就餐时，1、3、5 永远无法就餐，只能看着盘中的美食饥饿的等待着。</p> <h4 id="解决饥饿"><a href="#解决饥饿" class="header-anchor">#</a> <a href="https://dunwu.github.io/javacore/pages/f6b642/#%E8%A7%A3%E5%86%B3%E9%A5%A5%E9%A5%BF" target="_blank" rel="noopener noreferrer">#<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a>解决饥饿</h4> <p>Java 不可能实现 100% 的公平性，我们依然可以通过同步结构在线程间实现公平性的提高。</p> <p>有三种方案：</p> <ul><li>保证资源充足</li> <li>公平地分配资源</li> <li>避免持有锁的线程长时间执行</li></ul> <p>这三个方案中，方案一和方案三的适用场景比较有限，因为很多场景下，资源的稀缺性是没办法解决的，持有锁的线程执行的时间也很难缩短。倒是方案二的适用场景相对来说更多一些。</p> <p>那如何公平地分配资源呢？在并发编程里，主要是使用<strong>公平锁</strong>。所谓公平锁，是一种先来后到的方案，线程的等待是有顺序的，排在等待队列前面的线程会优先获得资源。</p> <h2 id="性能问题"><a href="#性能问题" class="header-anchor">#</a> 性能问题</h2> <p>并发执行一定比串行执行快吗？线程越多执行越快吗？</p> <p>答案是：<strong>并发不一定比串行快</strong>。因为有创建线程和线程上下文切换的开销。</p> <h3 id="上下文切换"><a href="#上下文切换" class="header-anchor">#</a> 上下文切换</h3> <h4 id="什么是上下文切换"><a href="#什么是上下文切换" class="header-anchor">#</a> 什么是上下文切换？</h4> <p>当 CPU 从执行一个线程切换到执行另一个线程时，CPU 需要保存当前线程的本地数据，程序指针等状态，并加载下一个要执行的线程的本地数据，程序指针等。这个开关被称为“上下文切换”。</p> <h4 id="减少上下文切换的方法"><a href="#减少上下文切换的方法" class="header-anchor">#</a> 减少上下文切换的方法</h4> <ul><li>无锁并发编程 - 多线程竞争锁时，会引起上下文切换，所以多线程处理数据时，可以用一些办法来避免使用锁，如将数据的 ID 按照 Hash 算法取模分段，不同的线程处理不同段的数据。</li> <li>CAS 算法 - Java 的 Atomic 包使用 CAS 算法来更新数据，而不需要加锁。</li> <li>使用最少线程 - 避免创建不需要的线程，比如任务很少，但是创建了很多线程来处理，这样会造成大量线程都处于等待状态。</li> <li>使用协程 - 在单线程里实现多任务的调度，并在单线程里维持多个任务间的切换。</li></ul> <h3 id="资源限制"><a href="#资源限制" class="header-anchor">#</a> 资源限制</h3> <h4 id="什么是资源限制"><a href="#什么是资源限制" class="header-anchor">#</a> 什么是资源限制</h4> <p>资源限制是指在进行并发编程时，程序的执行速度受限于计算机硬件资源或软件资源。</p> <h4 id="资源限制引发的问题"><a href="#资源限制引发的问题" class="header-anchor">#</a> 资源限制引发的问题</h4> <p>在并发编程中，将代码执行速度加快的原则是将代码中串行执行的部分变成并发执行，但是如果将某段串行的代码并发执行，因为受限于资源，仍然在串行执行，这时候程序不仅不会加快执行，反而会更慢，因为增加了上下文切换和资源调度的时间。</p> <h4 id="如何解决资源限制的问题"><a href="#如何解决资源限制的问题" class="header-anchor">#</a> 如何解决资源限制的问题</h4> <p>在资源限制情况下进行并发编程，根据不同的资源限制调整程序的并发度。</p> <ul><li>对于硬件资源限制，可以考虑使用集群并行执行程序。</li> <li>对于软件资源限制，可以考虑使用资源池将资源复用。</li></ul> <h2 id="小结"><a href="#小结" class="header-anchor">#</a> 小结</h2> <p>并发编程可以总结为三个核心问题：分工、同步、互斥。</p> <ul><li><strong>分工</strong>：是指如何高效地拆解任务并分配给线程。</li> <li><strong>同步</strong>：是指线程之间如何协作。</li> <li><strong>互斥</strong>：是指保证同一时刻只允许一个线程访问共享资源。</li></ul></div></div>  <div class="page-edit"><div class="edit-link"><a href="https://github.com/MrYz0/edit/master/docs/并发/31.Java并发简介.md" target="_blank" rel="noopener noreferrer">编辑</a> <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></div> <!----> <!----></div> <div class="page-nav-wapper"><div class="page-nav-centre-wrap"><!----> <a href="/JavaCore/pages/98dd93/" class="page-nav-centre page-nav-centre-next"><div class="tooltip">Java线程基础</div></a></div> <div class="page-nav"><p class="inner"><!----> <span class="next"><a href="/JavaCore/pages/98dd93/">Java线程基础</a>→
      </span></p></div></div></div> <div class="article-list"><div class="article-title"><a href="/JavaCore/archives/" class="iconfont icon-bi">最近更新</a></div> <div class="article-wrapper"><dl><dd>01</dd> <dt><a href="/JavaCore/pages/43ff41/"><div>
            深入理解Java String类型
            <!----></div></a> <span class="date">09-23</span></dt></dl><dl><dd>02</dd> <dt><a href="/JavaCore/pages/80ae21/"><div>
            Java常用工具类
            <!----></div></a> <span class="date">09-23</span></dt></dl><dl><dd>03</dd> <dt><a href="/JavaCore/pages/397652/"><div>
            深入理解Java注解
            <!----></div></a> <span class="date">09-23</span></dt></dl> <dl><dd></dd> <dt><a href="/JavaCore/archives/" class="more">更多文章&gt;</a></dt></dl></div></div></main></div> <div class="footer"><div class="icons"><a href="https://github.com/MrYz0" title="GitHub" target="_blank" class="iconfont icon-github"></a></div> 
  Theme by
  <a href="https://github.com/xugaoyi/vuepress-theme-vdoing" target="_blank" title="本站主题">Vdoing</a> 
    | Copyright © 2022-2022
    <span>Yang zhou | <a href="" target="_blank">MIT License</a></span></div> <div class="buttons"><div title="返回顶部" class="button blur go-to-top iconfont icon-fanhuidingbu" style="display:none;"></div> <div title="去评论" class="button blur go-to-comment iconfont icon-pinglun" style="display:none;"></div> <div title="主题模式" class="button blur theme-mode-but iconfont icon-zhuti"><ul class="select-box" style="display:none;"><li class="iconfont icon-zidong">
          跟随系统
        </li><li class="iconfont icon-rijianmoshi">
          浅色模式
        </li><li class="iconfont icon-yejianmoshi">
          深色模式
        </li><li class="iconfont icon-yuedu">
          阅读模式
        </li></ul></div></div> <!----> <!----> <!----></div><div class="global-ui"></div></div>
    <script src="/JavaCore/assets/js/app.dbe5bb79.js" defer></script><script src="/JavaCore/assets/js/2.cf8b9bc2.js" defer></script><script src="/JavaCore/assets/js/108.8037c42e.js" defer></script>
  </body>
</html>
